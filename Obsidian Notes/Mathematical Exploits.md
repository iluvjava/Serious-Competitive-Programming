## INTRO
* This section is concerned with mathematical exploits in coding challenges, Combinatorics. 
* [[Largest Number]] LeetCode, also asked by Google.
	* Major Exploit: Mathematical Relations, Sorting. 

### Relavent Topics
* Sorting is a sub category of the mathematical exploits. 
* Partial Order
* Transitive Closure

## Lexicographic Orderness
* Normal Lexicographic order
	* given 2 sequences there are 2 cases: 
		* They have the same length, then compare the sequence element wise using an alphabet to determine the relative size of the sequence. 
		* They have different length, pad the shorter one with a symbols that ranks lower than ALL characters on the alphabet.
	* A variance involves comparing the length of the sequences and always rank shorter sequence smaller, and then it proceed to compare the symbols in the sequence afterwards. It's called **shortlex**
* For the sake of discussion, let's limit the set of alphabet to be `a-z`, lowercased English letters. 
* Fact: Lexicographic orderness are transitive, hence **total order**[^1]

[^1]: Axioms: $a\leq b \wedge b\leq a \implies a = b$; $a\leq b \wedge b\leq c \implies a\leq c$, $a \leq b \vee b\leq a$.

### A Problem
* Given a collection of integers, arrange them in a permutation and then concatenate them like a string, find such a permutations that produce the lexicographical maximal string. 
* This is leetcode problem, [link](https://leetcode.com/problems/largest-number/)

### Discussion
* Consider we have 2 strings, `S1`, `S2`, and we want to determine whether the permutation `S1+S2` is larger or `S2+S1` is lager, which is simply, we do it just by comparing `S1 + S2` with `S2 + S1`. 
* Now, consider that we are given 3 strings, where `A, B, C` are string of non zero length, in this order`ABC`, and we want to find the minimal lexicographic order permutations of the block of strings.
* If, moving `C` to the front make it smaller, then `CAB < ABC`, let's denote it as `C<<AB`. 
* If, moving `C` to `B` makes it smaller, then `ACB < ACB`, which is `CB<=BC`, then `C<<B`. 
* Here, we natrually developed the notation of `a<<b` which means `ab<ba` in lexicographical order.
* Now let's consider a special kind of inputs: 
	* Prefix Coincidence
	* [33, 333, 332, 334]
	* desired output: [334, 333, 33, 332]
	* Loopback comparison, if 2 string have different length, then the longer one's extra digit should loop back and compare with the starting digit on the shorter one.

## A Naive Algorithm is Made 
* Here, we can use the routine of **bubble sort** or insertion sort to determine the best, minimal/maximal permutation. Let's focus on bubble sort.
* Let's say we have a fancier groups of strings, in a certain permutation.

$$
	(S_1)(S_2)(S_3)... (S_i)(S_j)... (S_n)
$$

* We ask: "does swap $S_i$ with $S_j$ make it lexicographically smaller?"
* Notice that, adjacent swaps of $S_i, S_j$ won't change the prefix from $S_1$ up to $S_{i - 1}$ and the postfix where $S_{j + 1}$ to $S_{n}$ so then, the only comparison which can make the difference is the substring $(S_i)(S_j)$ and $(S_j)(S_i)$. 
* Hence, we swap $S_i, S_j$ if $(S_j)(S_i)< (S_i)(S_j)$, else we don't. Or using our fancier notation, we swap it if $S_j << S_i$
* Why it works? 
* Assuming a base case of 2 string, the bubble sort algorithm will determine the minmial permutation. 
* Then, the first swap will assert that, the first block of string is in the correct order, $({S'}_1)...(S'_{n})$ are in the correct order.  (The `'` denotes that the bubble sort already touched it and it's the permutation afterwards, with the new index), string that starts with another other $S \neq {S'}_i$ will be larger than the string produced by the first bubble sort.
	* This part is asserted by the fact that, lexicographic orderness is **total order**
* The bubble sort assert that, the first element on the left side of the sequence after the first iteration of the outter loop has to be in the correct order. 
* Before:
	$$(S_1)(S_2)(S_3)...(S_n)$$
* after: 

	$$({S'}_1)({S'}_2)({S'}_3)...({S'}_n)$$

* Then, it the algorithm will assert that: ${S'}_1 << {S'}_i$ for all $2\leq i \leq n$. For contradiction, assume that, there eixsts ${S'}_j < {S'}_1$ with $j\neq 1$, then ${S'}_j$ will get bubbled up by the algorithm instead of ${S'}_1$
* Now, mask the ${S'}_1$ in the sequence, then apply the bubble sort algorithm recursively, the base case of 2 group of sting will be trivial to prove, and hence, this algorithm is correct.


## Questions to Ponder
* If the bubble sort algorithm works, does it mean that, all other algorithm works of the customized binary operator: `<<`? 
	* No, there is no gurantee, bubble sort is applicable to **Partiall Ordered Set**, and it will still be able to sort it, but other algorithm such as the quick sort, won't be applicable to such a set of elements. 
* What if the `<<` operator together with the set of elements form a **Total Order Set**? 
	* This is a good news, because it will means that, sorting algorithms for total orderset will be applicable with the operator, and after the sorting, we can assert that: 
	
$$
S_1 << S_2 << S_3 ... << S_n	
$$
  
  * Whic will  also means that, this is the minmial/maximal lexicographic, concatenated string because, any adjacnt swaps will reduce it to a larger/smaller lexicographical permutation.
  * **Conjecture**
	  * If bubble sort works, then the operator has to be transitive. 
  * What is absolutely true is that following: 
  
	  Bubble Sort  |  Assertion 
	  -----------------|----------------------
	  ABC  | Swap B, C
	  ACB | C<\<B
	  ACB | Swap AC
	  CAB | C<\<A
  
  * Hence: ABC < CAB, which also means that C << AB, this is a key to a divide and conquer soltuion where we treat the string as a whole instead of as seperate units.
  	$$
	A << B \wedge A << C \iff A << BC  \wedge A << CB
  $$
  * This is something interesting from our bubble sort algorithm. 
	$$
	A << C \wedge B << C \iff AB<<C
  $$
  
 
### Total Orderness
* Here is a list of axioms needed to a binary operator with a set is Total Order: 
	* Asymmetric
	* Transitive
	* Connexity
* Let's explore some of the properties of the `<<` operator on strings. 
* I can't prove this part, it seems like something is missing.
	* A plain discussion of the higher level patterns of << operations on string obscure the insights for the proof of transitivity
	* But this is correct because: [link](https://math.stackexchange.com/questions/1281726/is-concatenation-of-digit-strings-transitive)

### Proof of Transitivity under String Containing Digits
* Let's narrow our scope only ten digits, and get some idea on how transitivity can be proven using existing algebras. 
* Transitivity statement for the << binary operator
$$A << B \wedge B << C \implies A << C $$
* By definiton that means
$$AB < BA \wedge BC < CB \implies AC < CA$$
* Which is possible to be represented numerically. Here we denote the fact that $l(B)$ gives the length fothe number. 

$$A10^{l(B)} + B < B10^{l(A)} + A $$

$$A\times 10^{l(B)} - A < B\times 10^{l(A)} - B$$

$$A(10^{l(B)} - 1) < B(10^{l(A)} - 1)$$

$$A < \frac{B(10^{l(A)} - 1)}{10^{l(B)} - 1}$$

* Similarly we can have 
$$B < \frac{C (10^{l(B)} - 1)}{10^{l(C)} - 1}$$

* These things are directly from the 2 clauses from the hypothesis of the statement, and then, we can use the fact that, $B$ is smaller than the fractional quantity and substitute it into the previous inequality involving $A$. 

$$A <   \frac{C (10^{l(B)} - 1)}{10^{l(C)} - 1} \frac{10^{l(A)} - 1}{10^{l(B)} - 1}$$

$$ A < \frac{C(10^{l(A)} - 1)}{10^{l(C)} - 1}$$

* Notice that, this actually implies that, if we take things back to strings

$$AC < CA$$

$$A << C$$

* QED
* We can start with WLOG, and change 10 to fit the size of any alphabet, and the same argument applies, proving that, this is true for any sequences with that can be lexicographically ordred.
 
### What We Learned
* Sometimes mathmatical expoit in competitive programming is hard


### Another Exploit on Transitivity Relations
* [[Transitivity]]
* Read more about graph and relations here: [[Graph and Relations]]

